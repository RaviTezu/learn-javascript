*) Never use a anonymous function

*) Never use `eval` or `with` keywords in your code - In strict mode the `with` keyword is disabled. 

*) IIFE:
var foo = "foo";

(function() {

  var foo = "foof2";
  console.log(foo);  //"foo2"
})();

console.log(foo); //"foo"

- Wrapping the function with paranthesis will make it an fucnction expression.
- The variables declared in this function will not be leaked out.

OR 

var foo = "foo";
 
(function(bar){
  var foo = bar;
  console.log(foo); /"foo"

})(foo);

console.log(foo); /"foo"

*) let keyword in ES6: (Block scope)
- Where as, var is function scope
function foo() {
var bar = "bar";
for(let i=0; i < bar.length; i++){
  console.log(bar.charAt(i));
}
console.log(i); //RefernceError
}

foo();

- with "var" instead of "let", will attach the variable i to the function scope rather than the for block scope. so "let" is kinda hijacking the scope of for loop.

- function foo(bar) {
if (bar) {
  let baz = bar;
  if (baz) {
    let bam = baz;
  }
  console.log(bam); //Error
}
console.log(bam); //Error
}

foo("bar");

}

If you have a "let z = 2;" declared in a If statement at the middle, this z is available only from the middle of the If statement. So put all the lets at the top of the blocks.

- Note: This is rejected in ES6
function foo(bar) {
  let (baz = bar) {
    console.log(baz); //"bar"
  }
  console.log(baz); //Error
}

foo("bar");

So, use this:
- function foo(bar){
  /* let */ { let baz = bar;
    console.log(baz); //"bar"
  } console.log(baz); //Error
}
foo("bar");

A tool for use let-er to take the first example and returns the above form. So, it is like it will take the non-standart code and returns a standard code - These let-er or coffee-script are like transpilers.
